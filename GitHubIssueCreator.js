/**
 * GitHub Issue Creator from Meeting Recap Action Items
 * 
 * Creates GitHub issues from meeting recap action items and adds them
 * to the configured GitHub Project with "Generated" status.
 */

const GENERATED_STATUS_NAME = 'Generated';
const GITHUB_ISSUE_REPO_OWNER = 'johndavis92790';
const GITHUB_ISSUE_REPO_NAME = 'OP-Tasklist';
const MEETING_RECAP_SHEET_NAME = 'Meeting Recaps'; // Legacy sheet name for backward compatibility

/**
 * Create GitHub issues from action items in new meeting recaps
 * @param {Array} newRecaps - Array of newly imported recap objects
 * @returns {Object} Result summary
 */
function createGitHubIssuesFromRecaps(newRecaps) {
  if (!newRecaps || newRecaps.length === 0) {
    Logger.log('No new recaps to process for GitHub issues');
    return { created: 0, skipped: 0, errors: 0 };
  }
  
  Logger.log(`=== Creating GitHub Issues from ${newRecaps.length} recaps ===`);
  
  try {
    const config = validateGitHubConfig();
    
    // Ensure the auto-generated label exists
    ensureAutoGeneratedLabel(config.githubToken);
    
    // Get project field IDs (status, priority)
    const projectInfo = getProjectFieldInfo(config);
    if (!projectInfo) {
      Logger.log('ERROR: Could not retrieve project field info');
      return { created: 0, skipped: 0, errors: newRecaps.length };
    }
    
    let totalCreated = 0;
    let totalSkipped = 0;
    let totalErrors = 0;
    
    for (const recap of newRecaps) {
      const result = createIssuesFromRecap(recap, config, projectInfo);
      totalCreated += result.created;
      totalSkipped += result.skipped;
      totalErrors += result.errors;
    }
    
    Logger.log(`=== GitHub Issue Creation Complete: ${totalCreated} created, ${totalSkipped} skipped, ${totalErrors} errors ===`);
    
    return {
      created: totalCreated,
      skipped: totalSkipped,
      errors: totalErrors
    };
    
  } catch (error) {
    Logger.log('ERROR creating GitHub issues: ' + error.message);
    Logger.log(error.stack);
    return { created: 0, skipped: 0, errors: newRecaps.length };
  }
}

/**
 * Create issues from a single recap's action items
 */
function createIssuesFromRecap(recap, config, projectInfo) {
  let created = 0;
  let skipped = 0;
  let errors = 0;
  
  // Check if we've already created issues for this recap (use meetingLink as stable ID)
  if (hasIssuesBeenCreatedForRecap(recap.meetingLink)) {
    Logger.log(`  â­ï¸ Already processed: ${recap.meetingTitle}`);
    return { created: 0, skipped: 0, errors: 0 };
  }
  
  // Parse action items from JSON string
  let myActionItems = [];
  try {
    if (recap.myActionItems && recap.myActionItems !== '[]') {
      myActionItems = JSON.parse(recap.myActionItems);
    }
  } catch (e) {
    Logger.log(`  âŒ Failed to parse action items for ${recap.meetingTitle}: ${e.message}`);
    return { created: 0, skipped: 0, errors: 1 };
  }
  
  if (myActionItems.length === 0) {
    Logger.log(`  â­ï¸ No action items for: ${recap.meetingTitle}`);
    return { created: 0, skipped: 0, errors: 0 };
  }
  
  Logger.log(`  Processing ${myActionItems.length} action items from: ${recap.meetingTitle}`);
  
  const issueIds = [];
  
  for (const actionItem of myActionItems) {
    try {
      const issueResult = createIssueFromActionItem(actionItem, recap, config, projectInfo);
      if (issueResult.created) {
        created++;
        issueIds.push(issueResult.issueNodeId);
        Logger.log(`    âœ“ Created issue: ${actionItem.actionItemTitle}`);
      } else if (issueResult.skipped) {
        skipped++;
        Logger.log(`    â­ï¸ Skipped: ${actionItem.actionItemTitle}`);
      }
    } catch (error) {
      errors++;
      Logger.log(`    âŒ Error creating issue "${actionItem.actionItemTitle}": ${error.message}`);
    }
    
    // Rate limiting
    Utilities.sleep(200);
  }
  
  // Store the issue IDs back to the recap for tracking
  if (issueIds.length > 0) {
    recap.githubIssueIds = issueIds.join(', ');
  }
  
  return { created, skipped, errors, issueIds };
}

/**
 * Check if issues have already been created for this meeting recap
 * Uses meetingLink as the stable unique identifier (meetingRecapId is regenerated each import)
 */
function hasIssuesBeenCreatedForRecap(meetingLink) {
  try {
    if (!meetingLink) {
      return false;
    }
    
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const recapSheet = spreadsheet.getSheetByName(MEETING_RECAP_SHEET_NAME);
    
    if (!recapSheet || recapSheet.getLastRow() < 2) {
      return false;
    }
    
    const data = recapSheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices - use Meeting Link as stable identifier
    const meetingLinkIndex = headers.indexOf('Meeting Link');
    const issueIdsIndex = headers.indexOf('GitHub Issue IDs');
    
    if (meetingLinkIndex === -1 || issueIdsIndex === -1) {
      return false; // Can't check without required columns
    }
    
    // Find the row for this meeting recap by meeting link
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const rowMeetingLink = row[meetingLinkIndex] || '';
      
      // Handle HYPERLINK formula - extract URL if needed
      let linkValue = rowMeetingLink;
      if (typeof rowMeetingLink === 'string' && rowMeetingLink.includes('HYPERLINK')) {
        const match = rowMeetingLink.match(/HYPERLINK\("([^"]+)"/);
        if (match) {
          linkValue = match[1];
        }
      }
      
      if (linkValue === meetingLink) {
        const issueIds = row[issueIdsIndex] || '';
        
        // If there are any issue IDs, we've already processed this recap
        if (issueIds && issueIds.toString().trim()) {
          Logger.log(`    ðŸ” Already processed: Issues already created for this recap`);
          return true;
        }
        
        return false;
      }
    }
    
    return false;
  } catch (error) {
    Logger.log(`    âš ï¸ Error checking if issues were created: ${error.message}`);
    return false; // On error, allow creation to proceed
  }
}

/**
 * Create a single GitHub issue from an action item
 */
function createIssueFromActionItem(actionItem, recap, config, projectInfo) {
  const title = actionItem.actionItemTitle;
  const priority = actionItem.priority || '';
  
  // Build issue body with meeting context
  const body = buildIssueBody(actionItem, recap);
  
  // Build labels array
  const labels = ['auto-generated'];
  if (recap.accountName) {
    labels.push(ACCOUNT_LABEL_PREFIX + recap.accountName);
  }
  
  // Step 1: Create the issue via REST API
  const issueData = createGitHubIssue(
    config.githubToken,
    GITHUB_ISSUE_REPO_OWNER,
    GITHUB_ISSUE_REPO_NAME,
    title,
    body,
    labels
  );
  
  if (!issueData) {
    return { created: false, skipped: false };
  }
  
  const issueNodeId = issueData.node_id;
  const issueNumber = issueData.number;
  
  // Step 2: Add issue to project
  const projectItemId = addIssueToProject(config.githubToken, projectInfo.projectId, issueNodeId);
  
  if (!projectItemId) {
    Logger.log(`    âš ï¸ Issue #${issueNumber} created but failed to add to project`);
    return { created: true, issueNodeId: issueNodeId };
  }
  
  // Step 3: Set status to "Generated"
  if (projectInfo.statusFieldId && projectInfo.generatedOptionId) {
    setProjectItemField(
      config.githubToken,
      projectInfo.projectId,
      projectItemId,
      projectInfo.statusFieldId,
      projectInfo.generatedOptionId
    );
  }
  
  // Step 4: Set priority if available
  if (priority && projectInfo.priorityFieldId && projectInfo.priorityOptions) {
    const priorityOptionId = projectInfo.priorityOptions[priority];
    if (priorityOptionId) {
      setProjectItemField(
        config.githubToken,
        projectInfo.projectId,
        projectItemId,
        projectInfo.priorityFieldId,
        priorityOptionId
      );
    }
  }
  
  return { created: true, issueNodeId: issueNodeId };
}

/**
 * Build the issue body with action item description and meeting context
 */
function buildIssueBody(actionItem, recap) {
  const description = actionItem.actionItemDescription || '';
  
  // Format meeting date nicely
  let meetingDateStr = '';
  if (recap.meetingDate) {
    try {
      const meetingDate = new Date(recap.meetingDate);
      meetingDateStr = meetingDate.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    } catch (e) {
      meetingDateStr = recap.meetingDate;
    }
  }
  
  let body = description;
  
  // Add meeting context section
  body += '\n\n---\n\n';
  body += '## Meeting Context\n\n';
  body += `**Meeting:** ${recap.meetingTitle || 'Unknown'}\n`;
  if (meetingDateStr) {
    body += `**Date:** ${meetingDateStr}\n`;
  }
  if (recap.accountName) {
    body += `**Account:** ${recap.accountName}\n`;
  }
  if (recap.externalAttendees) {
    body += `**External Attendees:** ${recap.externalAttendees}\n`;
  }
  if (recap.meetingLink) {
    body += `**Meeting Recap:** [View Recap](${recap.meetingLink})\n`;
  }
  
  // Add full summary (not truncated)
  if (recap.summary) {
    body += `\n### Meeting Summary\n${recap.summary}\n`;
  }
  
  body += `\n---\n*Auto-generated from meeting recap on ${new Date().toISOString().split('T')[0]}*`;
  
  return body;
}

/**
 * Create a GitHub issue using REST API
 */
function createGitHubIssue(token, owner, repo, title, body, labels) {
  const url = `https://api.github.com/repos/${owner}/${repo}/issues`;
  
  const payload = {
    title: title,
    body: body,
    labels: labels
  };
  
  const options = {
    method: 'post',
    headers: {
      'Authorization': 'Bearer ' + token,
      'User-Agent': 'Google-Apps-Script',
      'Accept': 'application/vnd.github+json'
    },
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  
  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  
  if (responseCode !== 201) {
    Logger.log(`Failed to create issue: ${response.getContentText()}`);
    return null;
  }
  
  return JSON.parse(response.getContentText());
}

/**
 * Get project field information (IDs for status, priority, and their options)
 */
function getProjectFieldInfo(config) {
  const query = `
    query($login: String!, $number: Int!) {
      user(login: $login) {
        projectV2(number: $number) {
          id
          fields(first: 20) {
            nodes {
              ... on ProjectV2Field {
                id
                name
              }
              ... on ProjectV2SingleSelectField {
                id
                name
                options {
                  id
                  name
                }
              }
            }
          }
        }
      }
    }
  `;
  
  const variables = {
    login: config.githubUsername,
    number: config.projectNumber
  };
  
  const response = makeGitHubGraphQLRequest(config.githubToken, query, variables);
  
  if (!response.data || !response.data.user || !response.data.user.projectV2) {
    Logger.log('Failed to get project field info');
    return null;
  }
  
  const project = response.data.user.projectV2;
  const fields = project.fields.nodes;
  
  const info = {
    projectId: project.id,
    statusFieldId: null,
    generatedOptionId: null,
    priorityFieldId: null,
    priorityOptions: {}
  };
  
  for (const field of fields) {
    if (field.name && field.name.toLowerCase() === 'status' && field.options) {
      info.statusFieldId = field.id;
      for (const option of field.options) {
        if (option.name === GENERATED_STATUS_NAME) {
          info.generatedOptionId = option.id;
        }
      }
    } else if (field.name && field.name.toLowerCase() === 'priority' && field.options) {
      info.priorityFieldId = field.id;
      for (const option of field.options) {
        info.priorityOptions[option.name] = option.id;
      }
    }
  }
  
  Logger.log(`Project ID: ${info.projectId}`);
  Logger.log(`Status Field ID: ${info.statusFieldId}`);
  Logger.log(`Generated Option ID: ${info.generatedOptionId}`);
  Logger.log(`Priority Field ID: ${info.priorityFieldId}`);
  Logger.log(`Priority Options: ${JSON.stringify(info.priorityOptions)}`);
  
  if (!info.generatedOptionId) {
    Logger.log(`âš ï¸ WARNING: "${GENERATED_STATUS_NAME}" status not found in project. Issues will be created but status won't be set.`);
  }
  
  return info;
}

/**
 * Add an issue to a GitHub Project V2
 */
function addIssueToProject(token, projectId, issueNodeId) {
  const mutation = `
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {
        projectId: $projectId
        contentId: $contentId
      }) {
        item {
          id
        }
      }
    }
  `;
  
  const variables = {
    projectId: projectId,
    contentId: issueNodeId
  };
  
  const response = makeGitHubGraphQLRequest(token, mutation, variables);
  
  if (response.errors) {
    Logger.log(`Failed to add issue to project: ${JSON.stringify(response.errors)}`);
    return null;
  }
  
  if (response.data && response.data.addProjectV2ItemById && response.data.addProjectV2ItemById.item) {
    return response.data.addProjectV2ItemById.item.id;
  }
  
  return null;
}

/**
 * Set a single-select field value on a project item
 */
function setProjectItemField(token, projectId, itemId, fieldId, optionId) {
  const mutation = `
    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
      updateProjectV2ItemFieldValue(input: {
        projectId: $projectId
        itemId: $itemId
        fieldId: $fieldId
        value: {
          singleSelectOptionId: $optionId
        }
      }) {
        projectV2Item {
          id
        }
      }
    }
  `;
  
  const variables = {
    projectId: projectId,
    itemId: itemId,
    fieldId: fieldId,
    optionId: optionId
  };
  
  const response = makeGitHubGraphQLRequest(token, mutation, variables);
  
  if (response.errors) {
    Logger.log(`Failed to set field value: ${JSON.stringify(response.errors)}`);
    return false;
  }
  
  return true;
}

/**
 * Test function to create issues from recent meeting recaps
 */
function testCreateGitHubIssuesFromRecaps() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Get the most recent recap from the sheet for testing
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(MEETING_RECAP_SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      ui.alert('Test Failed', 'No meeting recaps found in sheet.', ui.ButtonSet.OK);
      return;
    }
    
    // Get headers and last row
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const lastRowData = sheet.getRange(sheet.getLastRow(), 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // Build recap object from row
    const recap = {};
    const fieldMapping = {
      'Meeting Recap ID': 'meetingRecapId',
      'Meeting Title': 'meetingTitle',
      'Meeting Date': 'meetingDate',
      'Summary': 'summary',
      'External Attendees': 'externalAttendees',
      'Account Name': 'accountName',
      'Meeting Link': 'meetingLink',
      'My Action Items (JSON)': 'myActionItems'
    };
    
    for (let i = 0; i < headers.length; i++) {
      const fieldName = fieldMapping[headers[i]];
      if (fieldName) {
        recap[fieldName] = lastRowData[i];
      }
    }
    
    Logger.log('Testing with recap: ' + recap.meetingTitle);
    Logger.log('Action items: ' + recap.myActionItems);
    
    const result = createGitHubIssuesFromRecaps([recap]);
    
    ui.alert(
      'Test Complete',
      `Created: ${result.created}\nSkipped: ${result.skipped}\nErrors: ${result.errors}\n\nCheck the logs for details.`,
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    Logger.log('Test failed: ' + error.message);
    Logger.log(error.stack);
    ui.alert('Test Failed', 'Error: ' + error.message, ui.ButtonSet.OK);
  }
}

/**
 * Debug function to check project field configuration
 */
function debugProjectFields() {
  try {
    const config = validateGitHubConfig();
    const projectInfo = getProjectFieldInfo(config);
    
    if (projectInfo) {
      Logger.log('=== Project Field Debug ===');
      Logger.log('Project ID: ' + projectInfo.projectId);
      Logger.log('Status Field ID: ' + projectInfo.statusFieldId);
      Logger.log('Generated Option ID: ' + projectInfo.generatedOptionId);
      Logger.log('Priority Field ID: ' + projectInfo.priorityFieldId);
      Logger.log('Priority Options: ' + JSON.stringify(projectInfo.priorityOptions, null, 2));
      
      SpreadsheetApp.getUi().alert(
        'Project Fields',
        `Project ID: ${projectInfo.projectId}\n\n` +
        `Status Field: ${projectInfo.statusFieldId ? 'âœ“' : 'âœ—'}\n` +
        `Generated Status: ${projectInfo.generatedOptionId ? 'âœ“ Found' : 'âœ— NOT FOUND'}\n` +
        `Priority Field: ${projectInfo.priorityFieldId ? 'âœ“' : 'âœ—'}\n` +
        `Priority Options: ${Object.keys(projectInfo.priorityOptions).join(', ')}`,
        SpreadsheetApp.getUi().ButtonSet.OK
      );
    }
  } catch (error) {
    Logger.log('Debug failed: ' + error.message);
    SpreadsheetApp.getUi().alert('Error', error.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Ensure the auto-generated label exists in the repository
 */
function ensureAutoGeneratedLabel(token) {
  const labelName = 'auto-generated';
  const labelColor = '6f42c1'; // Purple color
  
  try {
    // Check if label exists
    const url = `https://api.github.com/repos/${GITHUB_ISSUE_REPO_OWNER}/${GITHUB_ISSUE_REPO_NAME}/labels/${encodeURIComponent(labelName)}`;
    
    const checkOptions = {
      method: 'get',
      headers: {
        'Authorization': 'Bearer ' + token,
        'User-Agent': 'Google-Apps-Script',
        'Accept': 'application/vnd.github+json'
      },
      muteHttpExceptions: true
    };
    
    const checkResponse = UrlFetchApp.fetch(url, checkOptions);
    
    if (checkResponse.getResponseCode() === 200) {
      // Label already exists
      return true;
    }
    
    // Create the label
    const createUrl = `https://api.github.com/repos/${GITHUB_ISSUE_REPO_OWNER}/${GITHUB_ISSUE_REPO_NAME}/labels`;
    
    const createOptions = {
      method: 'post',
      headers: {
        'Authorization': 'Bearer ' + token,
        'User-Agent': 'Google-Apps-Script',
        'Accept': 'application/vnd.github+json'
      },
      contentType: 'application/json',
      payload: JSON.stringify({
        name: labelName,
        color: labelColor,
        description: 'Auto-generated from meeting recap action items'
      }),
      muteHttpExceptions: true
    };
    
    const createResponse = UrlFetchApp.fetch(createUrl, createOptions);
    
    if (createResponse.getResponseCode() === 201) {
      Logger.log(`Created "${labelName}" label in repository`);
      return true;
    }
    
    Logger.log(`Failed to create label: ${createResponse.getContentText()}`);
    return false;
    
  } catch (error) {
    Logger.log(`Error ensuring auto-generated label: ${error.message}`);
    return false;
  }
}

/**
 * ============================================================================
 * DUPLICATE ISSUE CLEANUP FUNCTIONS
 * ============================================================================
 */

/**
 * Find and delete duplicate GitHub issues that have "Generated" status
 * Keeps the oldest issue (lowest issue number) for each unique title
 */
function cleanupDuplicateGeneratedIssues() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const config = validateGitHubConfig();
    
    Logger.log('=== Starting Duplicate Issue Cleanup ===');
    
    // Step 1: Get all issues with 'Generated' status from the project
    const generatedIssues = getGeneratedStatusIssues(config);
    
    if (generatedIssues.length === 0) {
      Logger.log('No issues with Generated status found');
      ui.alert('Cleanup Complete', 'No issues with "Generated" status found.', ui.ButtonSet.OK);
      return { deleted: 0, kept: 0 };
    }
    
    Logger.log(`Found ${generatedIssues.length} issues with Generated status`);
    
    // Step 2: Group by title to find duplicates
    const issuesByTitle = new Map();
    for (const issue of generatedIssues) {
      const title = issue.title;
      if (!issuesByTitle.has(title)) {
        issuesByTitle.set(title, []);
      }
      issuesByTitle.get(title).push(issue);
    }
    
    // Step 3: Find duplicates (titles with more than one issue)
    const duplicatesToDelete = [];
    let keptCount = 0;
    
    for (const [title, issues] of issuesByTitle) {
      if (issues.length > 1) {
        // Sort by issue number (oldest first)
        issues.sort((a, b) => a.number - b.number);
        
        // Keep the first (oldest), mark the rest for deletion
        keptCount++;
        Logger.log(`  Keeping issue #${issues[0].number}: "${title}"`);
        
        for (let i = 1; i < issues.length; i++) {
          duplicatesToDelete.push(issues[i]);
          Logger.log(`  â†’ Marking for deletion: #${issues[i].number}`);
        }
      } else {
        keptCount++;
      }
    }
    
    if (duplicatesToDelete.length === 0) {
      Logger.log('No duplicate issues found');
      ui.alert('Cleanup Complete', `Found ${generatedIssues.length} issues with "Generated" status, but no duplicates.`, ui.ButtonSet.OK);
      return { deleted: 0, kept: keptCount };
    }
    
    // Step 4: Confirm with user before deleting
    const confirmResponse = ui.alert(
      'Confirm Deletion',
      `Found ${duplicatesToDelete.length} duplicate issues to delete.\n` +
      `Keeping ${keptCount} unique issues.\n\n` +
      `Do you want to proceed with closing/deleting the duplicates?`,
      ui.ButtonSet.YES_NO
    );
    
    if (confirmResponse !== ui.Button.YES) {
      Logger.log('User cancelled deletion');
      return { deleted: 0, kept: keptCount, cancelled: true };
    }
    
    // Step 5: Close the duplicate issues
    let deletedCount = 0;
    for (const issue of duplicatesToDelete) {
      try {
        const closed = closeGitHubIssue(config.githubToken, issue.number);
        if (closed) {
          deletedCount++;
          Logger.log(`  âœ“ Closed issue #${issue.number}: "${issue.title}"`);
        }
        // Rate limiting
        Utilities.sleep(300);
      } catch (error) {
        Logger.log(`  âœ— Failed to close issue #${issue.number}: ${error.message}`);
      }
    }
    
    Logger.log(`=== Cleanup Complete: ${deletedCount} duplicates closed, ${keptCount} kept ===`);
    
    ui.alert(
      'Cleanup Complete',
      `Closed ${deletedCount} duplicate issues.\nKept ${keptCount} unique issues.`,
      ui.ButtonSet.OK
    );
    
    return { deleted: deletedCount, kept: keptCount };
    
  } catch (error) {
    Logger.log('ERROR in cleanup: ' + error.message);
    Logger.log(error.stack);
    ui.alert('Cleanup Failed', 'Error: ' + error.message, ui.ButtonSet.OK);
    return { deleted: 0, kept: 0, error: error.message };
  }
}

/**
 * Get all issues from GitHub project that have "auto-generated" label
 * This finds ALL auto-generated issues regardless of status (Done, Generated, etc.)
 */
function getAutoGeneratedIssues(config) {
  const issues = [];
  let hasNextPage = true;
  let cursor = null;
  
  Logger.log('Fetching all auto-generated issues from GitHub project...');
  
  while (hasNextPage) {
    const query = `
      query($login: String!, $number: Int!, $cursor: String) {
        user(login: $login) {
          projectV2(number: $number) {
            items(first: 100, after: $cursor) {
              pageInfo {
                hasNextPage
                endCursor
              }
              nodes {
                id
                fieldValues(first: 10) {
                  nodes {
                    ... on ProjectV2ItemFieldSingleSelectValue {
                      name
                      field {
                        ... on ProjectV2SingleSelectField {
                          name
                        }
                      }
                    }
                  }
                }
                content {
                  ... on Issue {
                    id
                    number
                    title
                    state
                    labels(first: 10) {
                      nodes {
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    `;
    
    const variables = {
      login: config.githubUsername,
      number: config.projectNumber,
      cursor: cursor
    };
    
    const response = makeGitHubGraphQLRequest(config.githubToken, query, variables);
    
    if (!response.data || !response.data.user || !response.data.user.projectV2) {
      break;
    }
    
    const items = response.data.user.projectV2.items;
    
    for (const item of items.nodes) {
      if (!item.content || !item.content.number) continue;
      
      // Check for auto-generated label
      let hasAutoGeneratedLabel = false;
      if (item.content.labels && item.content.labels.nodes) {
        for (const label of item.content.labels.nodes) {
          if (label.name === 'auto-generated') {
            hasAutoGeneratedLabel = true;
            break;
          }
        }
      }
      
      // Include ALL issues with auto-generated label (any status, any state)
      if (hasAutoGeneratedLabel) {
        // Get status for logging
        let status = 'unknown';
        if (item.fieldValues && item.fieldValues.nodes) {
          for (const fieldValue of item.fieldValues.nodes) {
            if (fieldValue.field && fieldValue.field.name && 
                fieldValue.field.name.toLowerCase() === 'status') {
              status = fieldValue.name || 'none';
            }
          }
        }
        
        issues.push({
          nodeId: item.content.id,
          projectItemId: item.id,
          number: item.content.number,
          title: item.content.title,
          state: item.content.state,
          status: status
        });
      }
    }
    
    hasNextPage = items.pageInfo.hasNextPage;
    cursor = items.pageInfo.endCursor;
    
    Logger.log(`  Fetched ${issues.length} auto-generated issues so far...`);
  }
  
  Logger.log(`Total auto-generated issues found: ${issues.length}`);
  return issues;
}

/**
 * Legacy function - now calls getAutoGeneratedIssues
 */
function getGeneratedStatusIssues(config) {
  return getAutoGeneratedIssues(config);
}

/**
 * Close a GitHub issue by issue number
 */
function closeGitHubIssue(token, issueNumber) {
  const url = `https://api.github.com/repos/${GITHUB_ISSUE_REPO_OWNER}/${GITHUB_ISSUE_REPO_NAME}/issues/${issueNumber}`;
  
  const options = {
    method: 'patch',
    headers: {
      'Authorization': 'Bearer ' + token,
      'User-Agent': 'Google-Apps-Script',
      'Accept': 'application/vnd.github+json'
    },
    contentType: 'application/json',
    payload: JSON.stringify({
      state: 'closed',
      state_reason: 'not_planned'
    }),
    muteHttpExceptions: true
  };
  
  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  
  if (responseCode !== 200) {
    Logger.log(`Failed to close issue #${issueNumber}: ${response.getContentText()}`);
    return false;
  }
  
  return true;
}

/**
 * Delete a GitHub issue (requires admin permissions)
 * Note: This permanently deletes the issue - use with caution!
 */
function deleteGitHubIssue(token, issueNumber) {
  const config = validateGitHubConfig();
  const url = `https://api.github.com/repos/${config.repoOwner}/${config.repoName}/issues/${issueNumber}`;
  
  const options = {
    method: 'DELETE',
    headers: {
      'Authorization': `token ${token}`,
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'Google-Apps-Script'
    },
    muteHttpExceptions: true
  };
  
  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  
  if (responseCode === 204) {
    return true; // Successfully deleted
  } else if (responseCode === 403) {
    Logger.log(`Cannot delete issue #${issueNumber}: Requires admin permissions`);
    return false;
  } else {
    Logger.log(`Failed to delete issue #${issueNumber}: ${response.getContentText()}`);
    return false;
  }
}

/**
 * Delete (permanently) duplicate GitHub issues with Generated status
 * This removes them entirely rather than just closing them
 */
function deleteDuplicateGeneratedIssues() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const config = validateGitHubConfig();
    
    Logger.log('=== Finding Duplicate Issues to DELETE ===');
    
    const generatedIssues = getGeneratedStatusIssues(config);
    
    if (generatedIssues.length === 0) {
      ui.alert('No Issues Found', 'No issues with Generated status found.', ui.ButtonSet.OK);
      return;
    }
    
    // Group by title
    const issuesByTitle = new Map();
    for (const issue of generatedIssues) {
      if (!issuesByTitle.has(issue.title)) {
        issuesByTitle.set(issue.title, []);
      }
      issuesByTitle.get(issue.title).push(issue);
    }
    
    // Find duplicates
    const duplicatesToDelete = [];
    let keptCount = 0;
    
    for (const [title, issues] of issuesByTitle) {
      if (issues.length > 1) {
        issues.sort((a, b) => a.number - b.number);
        keptCount++;
        for (let i = 1; i < issues.length; i++) {
          duplicatesToDelete.push(issues[i]);
        }
      } else {
        keptCount++;
      }
    }
    
    if (duplicatesToDelete.length === 0) {
      ui.alert('No Duplicates', 'No duplicate issues found to delete.', ui.ButtonSet.OK);
      return;
    }
    
    // Confirm deletion
    const confirmResponse = ui.alert(
      'âš ï¸ Permanent Deletion Warning',
      `Found ${duplicatesToDelete.length} duplicate issues to DELETE.\n\n` +
      `This will PERMANENTLY delete these issues (not just close them).\n` +
      `Keeping ${keptCount} original issues.\n\n` +
      `âš ï¸ This action cannot be undone!\n\n` +
      `Continue with permanent deletion?`,
      ui.ButtonSet.YES_NO
    );
    
    if (confirmResponse !== ui.Button.YES) {
      return;
    }
    
    // Delete duplicates
    let deletedCount = 0;
    let failedCount = 0;
    
    for (const issue of duplicatesToDelete) {
      Logger.log(`Deleting issue #${issue.number}: ${issue.title}`);
      
      if (deleteGitHubIssue(config.githubToken, issue.number)) {
        deletedCount++;
        Logger.log(`  âœ“ Deleted`);
      } else {
        failedCount++;
        Logger.log(`  âœ— Failed to delete (may need admin permissions)`);
      }
      
      Utilities.sleep(300); // Rate limiting
    }
    
    Logger.log(`\n=== Deletion Complete ===`);
    Logger.log(`Deleted: ${deletedCount}`);
    Logger.log(`Failed: ${failedCount}`);
    Logger.log(`Kept: ${keptCount}`);
    
    if (failedCount > 0) {
      ui.alert(
        'Deletion Partially Complete',
        `Deleted: ${deletedCount} issues\n` +
        `Failed: ${failedCount} issues (may require admin permissions)\n` +
        `Kept: ${keptCount} original issues\n\n` +
        `Note: If deletion failed, your GitHub token may not have admin permissions.\n` +
        `In that case, use "Close Duplicate Issues" instead.`,
        ui.ButtonSet.OK
      );
    } else {
      ui.alert(
        'Deletion Complete',
        `âœ… Permanently deleted ${deletedCount} duplicate issues.\n` +
        `Kept ${keptCount} original issues.`,
        ui.ButtonSet.OK
      );
    }
    
  } catch (error) {
    Logger.log('ERROR: ' + error.message);
    Logger.log(error.stack);
    ui.alert('Error', error.message, ui.ButtonSet.OK);
  }
}

/**
 * Debug function to see what the API is returning
 */
function debugGeneratedIssues() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const config = validateGitHubConfig();
    
    Logger.log('=== DEBUG: Querying GitHub API ===');
    Logger.log(`Username: ${config.githubUsername}`);
    Logger.log(`Project Number: ${config.projectNumber}`);
    
    // Query ALL project items to see what we're getting
    const query = `
      query($login: String!, $number: Int!) {
        user(login: $login) {
          projectV2(number: $number) {
            title
            items(first: 100) {
              totalCount
              nodes {
                id
                fieldValues(first: 10) {
                  nodes {
                    ... on ProjectV2ItemFieldSingleSelectValue {
                      name
                      field {
                        ... on ProjectV2SingleSelectField {
                          name
                        }
                      }
                    }
                  }
                }
                content {
                  ... on Issue {
                    number
                    title
                    state
                    labels(first: 10) {
                      nodes {
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    `;
    
    const variables = {
      login: config.githubUsername,
      number: config.projectNumber
    };
    
    const response = makeGitHubGraphQLRequest(config.githubToken, query, variables);
    
    if (!response.data || !response.data.user || !response.data.user.projectV2) {
      Logger.log('ERROR: No project data returned');
      Logger.log(JSON.stringify(response, null, 2));
      ui.alert('Error', 'No project data returned. Check logs.', ui.ButtonSet.OK);
      return;
    }
    
    const project = response.data.user.projectV2;
    Logger.log(`Project: ${project.title}`);
    Logger.log(`Total items: ${project.items.totalCount}`);
    
    let generatedCount = 0;
    let withLabelCount = 0;
    let openCount = 0;
    let matchesAllCriteria = 0;
    
    for (const item of project.items.nodes) {
      if (!item.content || !item.content.number) continue;
      
      let status = 'unknown';
      let hasAutoGeneratedLabel = false;
      
      // Get status
      if (item.fieldValues && item.fieldValues.nodes) {
        for (const fv of item.fieldValues.nodes) {
          if (fv.field && fv.field.name && fv.field.name.toLowerCase() === 'status') {
            status = fv.name || 'none';
          }
        }
      }
      
      // Get labels
      const labels = [];
      if (item.content.labels && item.content.labels.nodes) {
        for (const label of item.content.labels.nodes) {
          labels.push(label.name);
          if (label.name === 'auto-generated') {
            hasAutoGeneratedLabel = true;
          }
        }
      }
      
      const isGenerated = (status === 'Generated');
      const isOpen = (item.content.state === 'OPEN');
      
      if (isGenerated) generatedCount++;
      if (hasAutoGeneratedLabel) withLabelCount++;
      if (isOpen) openCount++;
      
      if (isGenerated && hasAutoGeneratedLabel && isOpen) {
        matchesAllCriteria++;
        Logger.log(`âœ“ #${item.content.number}: "${item.content.title.substring(0, 50)}..." [Status=${status}, Labels=${labels.join(',')}]`);
      } else if (isGenerated || hasAutoGeneratedLabel) {
        Logger.log(`âœ— #${item.content.number}: Status=${status}, Labels=${labels.join(',')}, State=${item.content.state}`);
      }
    }
    
    Logger.log(`\n=== Summary ===`);
    Logger.log(`Generated status: ${generatedCount}`);
    Logger.log(`auto-generated label: ${withLabelCount}`);
    Logger.log(`OPEN state: ${openCount}`);
    Logger.log(`Matches ALL criteria: ${matchesAllCriteria}`);
    
    ui.alert(
      'Debug Results',
      `Generated status: ${generatedCount}\n` +
      `auto-generated label: ${withLabelCount}\n` +
      `OPEN state: ${openCount}\n` +
      `Matches ALL criteria: ${matchesAllCriteria}\n\n` +
      `Check logs for details.`,
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    Logger.log('ERROR: ' + error.message);
    Logger.log(error.stack);
    ui.alert('Error', error.message, ui.ButtonSet.OK);
  }
}

/**
 * Preview duplicate issues without deleting (for testing)
 */
function previewDuplicateGeneratedIssues() {
  try {
    const config = validateGitHubConfig();
    
    Logger.log('=== Previewing Duplicate Issues ===');
    
    const generatedIssues = getGeneratedStatusIssues(config);
    
    Logger.log(`Found ${generatedIssues.length} issues with Generated status and auto-generated label`);
    
    // Group by title
    const issuesByTitle = new Map();
    for (const issue of generatedIssues) {
      const title = issue.title;
      if (!issuesByTitle.has(title)) {
        issuesByTitle.set(title, []);
      }
      issuesByTitle.get(title).push(issue);
    }
    
    // Report duplicates
    let totalDuplicates = 0;
    let uniqueTitles = 0;
    
    for (const [title, issues] of issuesByTitle) {
      if (issues.length > 1) {
        issues.sort((a, b) => a.number - b.number);
        Logger.log(`\nDuplicate title: "${title}"`);
        Logger.log(`  Keep: #${issues[0].number}`);
        for (let i = 1; i < issues.length; i++) {
          Logger.log(`  Delete: #${issues[i].number}`);
          totalDuplicates++;
        }
      }
      uniqueTitles++;
    }
    
    Logger.log(`\n=== Summary ===`);
    Logger.log(`Total issues with Generated status: ${generatedIssues.length}`);
    Logger.log(`Unique titles: ${uniqueTitles}`);
    Logger.log(`Duplicates to delete: ${totalDuplicates}`);
    
    SpreadsheetApp.getUi().alert(
      'Duplicate Preview',
      `Total issues with Generated status: ${generatedIssues.length}\n` +
      `Unique titles: ${uniqueTitles}\n` +
      `Duplicates to delete: ${totalDuplicates}\n\n` +
      `Check the logs for details.`,
      SpreadsheetApp.getUi().ButtonSet.OK
    );
    
    return {
      total: generatedIssues.length,
      unique: uniqueTitles,
      duplicates: totalDuplicates
    };
    
  } catch (error) {
    Logger.log('ERROR: ' + error.message);
    Logger.log(error.stack);
    SpreadsheetApp.getUi().alert('Error', error.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Run full duplicate cleanup - all steps in sequence
 * This is the recommended way to clean up after the duplicate bug
 */
function runFullDuplicateCleanup() {
  const ui = SpreadsheetApp.getUi();
  
  const confirmResponse = ui.alert(
    'Full Duplicate Cleanup',
    'This will run all cleanup steps:\n\n' +
    '1. Deduplicate Meeting Recaps sheet\n' +
    '2. Close duplicate GitHub issues (Generated status)\n' +
    '3. Clear GitHub Issue IDs to reset tracking\n\n' +
    'This may take a few minutes. Continue?',
    ui.ButtonSet.YES_NO
  );
  
  if (confirmResponse !== ui.Button.YES) {
    return;
  }
  
  Logger.log('=== Starting Full Duplicate Cleanup ===');
  
  try {
    // Step 1: Deduplicate Meeting Recaps sheet
    Logger.log('Step 1: Deduplicating Meeting Recaps sheet...');
    const recapResult = deduplicateMeetingRecapsSheetSilent();
    Logger.log(`  Deleted ${recapResult.deleted} duplicate recap rows`);
    
    // Step 2: Close duplicate GitHub issues
    Logger.log('Step 2: Closing duplicate GitHub issues...');
    const githubResult = cleanupDuplicateGeneratedIssuesSilent();
    Logger.log(`  Closed ${githubResult.deleted} duplicate issues, kept ${githubResult.kept}`);
    
    // Step 3: Clear GitHub Issue IDs
    Logger.log('Step 3: Clearing GitHub Issue IDs from recaps...');
    const clearResult = clearGitHubIssueIdsFromRecapsSilent();
    Logger.log(`  Cleared ${clearResult.cleared} rows`);
    
    Logger.log('=== Full Cleanup Complete ===');
    
    ui.alert(
      'Cleanup Complete',
      `âœ… Full cleanup finished!\n\n` +
      `Meeting Recaps: ${recapResult.deleted} duplicate rows removed\n` +
      `GitHub Issues: ${githubResult.deleted} duplicates closed, ${githubResult.kept} kept\n` +
      `Tracking Reset: ${clearResult.cleared} rows cleared\n\n` +
      `The 15-minute trigger will now work correctly.`,
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    Logger.log('ERROR in full cleanup: ' + error.message);
    Logger.log(error.stack);
    ui.alert('Cleanup Failed', 'Error: ' + error.message + '\n\nCheck logs for details.', ui.ButtonSet.OK);
  }
}

/**
 * Silent version of deduplicateMeetingRecapsSheet (no UI prompts)
 */
function deduplicateMeetingRecapsSheetSilent() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName(MEETING_RECAP_SHEET_NAME);
  
  if (!sheet || sheet.getLastRow() < 2) {
    return { deleted: 0 };
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const meetingLinkIndex = headers.indexOf('Meeting Link');
  
  if (meetingLinkIndex === -1) {
    return { deleted: 0 };
  }
  
  const data = sheet.getDataRange().getValues();
  const seenMeetingLinks = new Set();
  const rowsToDelete = [];
  
  for (let i = 1; i < data.length; i++) {
    let meetingLink = data[i][meetingLinkIndex] || '';
    
    if (typeof meetingLink === 'string' && meetingLink.includes('HYPERLINK')) {
      const match = meetingLink.match(/HYPERLINK\("([^"]+)"/);
      if (match) meetingLink = match[1];
    }
    
    if (!meetingLink) continue;
    
    if (seenMeetingLinks.has(meetingLink)) {
      rowsToDelete.push(i + 1);
    } else {
      seenMeetingLinks.add(meetingLink);
    }
  }
  
  rowsToDelete.sort((a, b) => b - a);
  for (const rowNum of rowsToDelete) {
    sheet.deleteRow(rowNum);
  }
  
  return { deleted: rowsToDelete.length };
}

/**
 * Silent version of cleanupDuplicateGeneratedIssues (no UI prompts)
 */
function cleanupDuplicateGeneratedIssuesSilent() {
  const config = validateGitHubConfig();
  const generatedIssues = getGeneratedStatusIssues(config);
  
  if (generatedIssues.length === 0) {
    return { deleted: 0, kept: 0 };
  }
  
  const issuesByTitle = new Map();
  for (const issue of generatedIssues) {
    if (!issuesByTitle.has(issue.title)) {
      issuesByTitle.set(issue.title, []);
    }
    issuesByTitle.get(issue.title).push(issue);
  }
  
  const duplicatesToDelete = [];
  let keptCount = 0;
  
  for (const [title, issues] of issuesByTitle) {
    if (issues.length > 1) {
      issues.sort((a, b) => a.number - b.number);
      keptCount++;
      for (let i = 1; i < issues.length; i++) {
        duplicatesToDelete.push(issues[i]);
      }
    } else {
      keptCount++;
    }
  }
  
  let deletedCount = 0;
  for (const issue of duplicatesToDelete) {
    try {
      if (closeGitHubIssue(config.githubToken, issue.number)) {
        deletedCount++;
      }
      Utilities.sleep(300);
    } catch (error) {
      Logger.log(`Failed to close issue #${issue.number}: ${error.message}`);
    }
  }
  
  return { deleted: deletedCount, kept: keptCount };
}

/**
 * Silent version of clearGitHubIssueIdsFromRecaps (no UI prompts)
 */
function clearGitHubIssueIdsFromRecapsSilent() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = spreadsheet.getSheetByName(MEETING_RECAP_SHEET_NAME);
  
  if (!sheet || sheet.getLastRow() < 2) {
    return { cleared: 0 };
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const githubIssueIdsIndex = headers.indexOf('GitHub Issue IDs');
  
  if (githubIssueIdsIndex === -1) {
    return { cleared: 0 };
  }
  
  const numRows = sheet.getLastRow() - 1;
  if (numRows > 0) {
    sheet.getRange(2, githubIssueIdsIndex + 1, numRows, 1).clearContent();
  }
  
  return { cleared: numRows };
}

/**
 * Clear all GitHub Issue IDs from the Meeting Recaps sheet
 * Use this after cleaning up duplicates to reset the tracking
 */
function clearGitHubIssueIdsFromRecaps() {
  const ui = SpreadsheetApp.getUi();
  
  const confirmResponse = ui.alert(
    'Confirm Clear',
    'This will clear all GitHub Issue IDs from the Meeting Recaps sheet.\n\n' +
    'This is useful after cleaning up duplicates so the system can re-track issues properly.\n\n' +
    'Proceed?',
    ui.ButtonSet.YES_NO
  );
  
  if (confirmResponse !== ui.Button.YES) {
    return;
  }
  
  try {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(MEETING_RECAP_SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      ui.alert('No Data', 'No meeting recaps found.', ui.ButtonSet.OK);
      return;
    }
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const githubIssueIdsIndex = headers.indexOf('GitHub Issue IDs');
    
    if (githubIssueIdsIndex === -1) {
      ui.alert('Column Not Found', 'GitHub Issue IDs column not found.', ui.ButtonSet.OK);
      return;
    }
    
    // Clear the GitHub Issue IDs column (except header)
    const numRows = sheet.getLastRow() - 1;
    if (numRows > 0) {
      sheet.getRange(2, githubIssueIdsIndex + 1, numRows, 1).clearContent();
    }
    
    Logger.log(`Cleared GitHub Issue IDs from ${numRows} rows`);
    ui.alert('Complete', `Cleared GitHub Issue IDs from ${numRows} rows.`, ui.ButtonSet.OK);
    
  } catch (error) {
    Logger.log('ERROR: ' + error.message);
    ui.alert('Error', error.message, ui.ButtonSet.OK);
  }
}
